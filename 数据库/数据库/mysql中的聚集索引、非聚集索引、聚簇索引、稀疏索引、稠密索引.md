# 一、[mysql中的聚集索引、非聚集索引、聚簇索引、稀疏索引、稠密索引](https://blog.csdn.net/guzhangyu12345/article/details/96423704)

**目录**

 

[首先介绍这些索引的概念：](https://blog.csdn.net/guzhangyu12345/article/details/96423704#t1)

[接着结合mysql进行讲解：](https://blog.csdn.net/guzhangyu12345/article/details/96423704#t2)

------

## 首先介绍这些索引的概念：

## 1、[聚集索引](https://so.csdn.net/so/search?q=聚集索引)

聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引 

也就是说聚集索引的顺序就是数据的物理存储顺序。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。

![img](https://img-blog.csdnimg.cn/20190718094626847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1emhhbmd5dTEyMzQ1,size_16,color_FFFFFF,t_70)

比如字典中，用‘拼音’查汉字，就是聚集索引。因为正文中字都是按照拼音排序的。而用‘偏旁部首’查汉字，就是非聚集索引，因为正文中的字并不是按照偏旁部首排序的，我们通过检字表得到正文中的字在索引中的映射，然后通过映射找到所需要的字。

聚集索引的使用场合为： 

　　a.查询命令的回传结果是以该字段为排序依据的； 

　　b.查询的结果返回一个区间的值； 

　　c.查询的结果返回某值相同的大量结果集。 

聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。 

## 2、非聚集索引

索引顺序与物理存储顺序不同![img](https://img-blog.csdnimg.cn/20190718094626854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1emhhbmd5dTEyMzQ1,size_16,color_FFFFFF,t_70)

非聚集索引的使用场合为： 

　　a.查询所获数据量较少时； 

　　b.某字段中的数据的唯一性比较高时；

非聚集索引必须是稠密索引

## 3、[聚簇索引](https://so.csdn.net/so/search?q=聚簇索引)

==聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。==术语“聚族”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚族索引。 

![img](https://img-blog.csdnimg.cn/20190718094627513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1emhhbmd5dTEyMzQ1,size_16,color_FFFFFF,t_70)

聚族索引的优点 

可以把相关数据保存在一起。就好像在操场上战队，一个院系一个院系的站在一起，这样要找到一个人，就先找到他的院系，然后在他的院系里找到他就行了，而不是把学校里的所有人都遍历一遍

数据访问更快。聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快

## 4、稠密索引

稠密索引：每个索引键值都对应有一个索引项

![img](https://img-blog.csdnimg.cn/20190718094627326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1emhhbmd5dTEyMzQ1,size_16,color_FFFFFF,t_70)

稠密索引能够比稀疏索引更快的定位一条记录。但是，稀疏索引相比于稠密索引的优点是：它所占空间更小，且插入和删除时的维护开销也小。

## 5、稀疏索引

稀疏索引：相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。 

![img](https://img-blog.csdnimg.cn/20190718094628408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1emhhbmd5dTEyMzQ1,size_16,color_FFFFFF,t_70)

 

## 接着结合mysql进行讲解：

mysql的两种数据存储方式，一种是InnoDB，一种是MyISAM。这两种存储都是基于B+树的存储方式，但是也有点不同。

MyIsam 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。主索引和辅助索引没有区别都是非聚集索引。索引页正常大小为1024字节，索引页存放在.MYI 文件中。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。

InnoDB 也使用B+Tree作为索引结构，索引页大小16，和表数据页共同存放在表空间中。从InnoDB表数据存放方式可看出InnoDB表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

InnoDB默认对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，InnoDB 会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。

所以mysql innodb引擎的聚集索引、聚簇索引都默认是主键索引，如果没有指定主键，就是一个具有唯一且非空值的索引，如果不存在这样的索引，就是InnoDB自定义的隐藏主键索引，并且该索引是稠密索引。



**推荐查看《高性能MySQL》的第5章 创建高性能的索引**



----

# 二、[聚簇索引(Clustered Index)和非聚簇索引 (Non- Clustered Index)](https://blog.csdn.net/luzhensmart/article/details/83479559)

**索引的重要性**
数据库性能优化中索引绝对是一个重量级的因素，可以说，索引使用不当，其它优化措施将毫无意义。

**聚簇索引**(Clustered Index)**和非聚簇索引** (Non- Clustered Index)
最通俗的解释是:[聚簇索引](https://so.csdn.net/so/search?q=聚簇索引)的顺序就是数据的物理存储顺序，而对非聚簇索引的索引顺序与数据物理排列顺序无关。举例来说，你翻到新华字典的汉字“爬”那一页就是P开头的部分，这就是物理存储顺序（聚簇索引）；而不用你到目录，找到汉字“爬”所在的页码，然后根据页码找到这个字（非聚簇索引）。

**聚簇索引的唯一性**
正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引，所以它显得更为珍贵，一个表设置什么为聚簇索引对性能很关键。

### 非聚簇索引

索引节点的叶子页面就好比一片叶子。叶子头便是索引键值。

先创建一张表：

```sql
CREATE TABLE `user` ( 



`id` INT NOT NULL ,



`name` VARCHAR NOT NULL ,



`class` VARCHAR NOT NULL);
```

对于MYISAM引擎，如果创建 id 和 name 为索引。对于下面查询：

```sql
select * from user where id = 1
```

会利用索引，先在索引树中快速检索到 id，但是要想取到id对应行数据，必须找到该行数据在硬盘中的存储位置，因此MYISAM引擎的索引 叶子页面上不仅存储了主键id 还存储着 数据存储的地址信息。如图：

![这里写图片描述](https://img-blog.csdn.net/20161230111325510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF0aGFtSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

像这样的索引就称为非聚簇索引。

非聚簇索引的二级索引与主键索引类似。假设我们对name添加索引，那么name的索引树叶子将是如下结构：

![这里写图片描述](https://img-blog.csdn.net/20161230112531936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF0aGFtSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

### 聚簇索引

==对于 非聚簇索引 来说，每次通过索引检索到所需行号后，还需要通过叶子上的磁盘地址去磁盘内取数据（回行）消耗时间。为了优化这部分回行取数据时间，InnoDB 引擎采用了聚簇索引。== 
聚簇索引，即将数据存入索引叶子页面上。对于 InnoDB 引擎来说，叶子页面不再存该行对应的地址，而是直接存储数据：

![这里写图片描述](https://img-blog.csdn.net/20161230132825473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF0aGFtSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

这样便避免了回行操作所带来的时间消耗。 使得 InnoDB 在某些查询上比 MyISAM 还要快！

==ps. 关于查询时间，一般认为 MyISAM 牺牲了功能换取了性能，查询更快。但事实并不一定如此。多数情况下，MyISAM 确实比 InnoDB 查的快 。但是查询时间受多方面因素影响。InnoDB 查询变慢得原因是因为支持事务、回滚等等，使得 InnoDB的叶子页面实际上还包含有事务id（换句话说就是版本号） 以及回滚指针。==

==在二级索引方面， InnoDB 与 MyISAM 有很大区别。==

==InnoDB默认对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，InnoDB 会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。==

假设对 InnoDB 引擎上表name字段加索引，那么name索引叶子页面则只会存储主键id：

![这里写图片描述](https://img-blog.csdn.net/20161230133010025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF0aGFtSg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

检索时，先通过name索引树找到主索引id，再通过id在主索引树的聚簇索引叶子页面取出数据。



---

# 三、[主键和聚集索引，单列索引和多列索引](https://www.cnblogs.com/chinaoarq/p/3690362.html)

## **1. 主键与聚集索引**

　　主键等同于聚集索引吗？（读者：当然不是啦，如果是，微软也不会叫两个不同的名字啦！）

　　首先，一个表只能有一个主键也只能有一个聚集索引，数据在物理上是按照聚集索引的顺序来存放的。

　　但是，主键可分为聚集的主键和非聚集的主键。在创建主键时，如果不指定类型，则默认创建的是聚集的主键。下面代码是SqlServer自动生成的CREATE TABLE 代码，注意设定主键那句话中的'CLUSTERED’，即表示聚集的主键。所以，主键并不等同于聚集索引，只有聚集的主键才是聚集索引。

```xml
CREATE TABLE [dbo].[User](
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [SchoolId] [nvarchar](50) NOT NULL,
    [StudentId] [nvarchar](50) NOT NULL,
    [TimeLine] [nvarchar](50) NOT NULL,
    [Name] [nvarchar](50) NULL,
    [Phone] [nvarchar](50) NULL,
    [Gender] [nvarchar](50) NULL,
    [Age] [smallint] NULL,
    [IdCard] [nvarchar](50) NULL,
    [Nation] [nvarchar](50) NULL,
    [Party] [nvarchar](50) NULL,
    [Birthday] [nvarchar](50) NULL,
    [Married] [nvarchar](50) NULL,
    [School] [nvarchar](50) NULL,
    [Degree] [nvarchar](50) NULL,
    [Province] [nvarchar](50) NULL,
    [City] [nvarchar](50) NULL,
    [Area] [nvarchar](50) NULL,
    [Address] [nvarchar](50) NULL,
    [College] [nvarchar](50) NULL,
    [Major] [nvarchar](50) NULL,
    [Class] [nvarchar](50) NULL,
    [Extra] [text] NULL,
PRIMARY KEY CLUSTERED 
(
    [Id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
```



## 2. 多列索引和多个单列索引

　　多列索引即是一个索引包含多个字段的情况；

　　多个单列索引即是每个索引只包含一个字段，但是有多个索引。

 

　　考虑两种不同的建立索引方式：

　　case 1：对c1,c2,c3三列按此顺序添加一个多列索引；

　　case 2： 对c1,c2,c3分别建立三个单列索引；



　　问题1：按c1搜索时，哪种索引效率快？

　　答：case2

　　问题2：按C2搜索时，哪种索引效率快？

　　答：case2，并且，case1的索引无效

　　问题3：按C1，C2搜索时哪种效率快？

　　答：case1,c3未用到

　　问题4：按C1,C2,C3搜索哪种效率快？

　　答：case1

　　问题5：按C2,C3,C1搜索时哪种效率快？

　　答：case2，因为没有按多列索引的顺序搜索，case1的索引没有使用到。

## 3. 覆盖查询

　　所谓覆盖查询简单的说就是所有查询列被所使用的索引覆盖的查询。

## 4. 单个表中索引太多的负面影响

　　当一个表存在多个（单列）索引，将造成Delete ，update ，insert操作需要花费大量的时间删除索引和重建索引。

　　通过把多个（单列）索引合并成一个（多列）索引后，测试得出Delete ，update ，insert操作时需要花费的时间大大缩短。但是这样可能会对之前单列索引字段的查询性能有影响。个中好处，权衡取舍。



----

# 四、[聚集索引和非聚集索引（整理）](https://www.cnblogs.com/aspnethot/articles/1504082.html)

## 1、聚集索引

　　一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。
　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。
　　　　
　　　　 **聚集索引对于那些经常要==搜索范围值的列==特别有效。**使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行 的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此 类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节 省成本。
　　　　

　　　　 当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。

 

 

 

## 2、非聚集索引

　　一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

 

 

索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。如下图：

 

 ![img](mysql中的聚集索引、非聚集索引、聚簇索引、稀疏索引、稠密索引.assets/Pic10.JPG)

 

​                   （非聚集索引）

 

 

 

 

 

![img](mysql中的聚集索引、非聚集索引、聚簇索引、稀疏索引、稠密索引.assets/Pic11.JPG) 

 

​                   （聚集索引）

 

 

##   3、深入浅出理解索引结构

  　　实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：
  　　其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。
  　　如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。
  　　通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。

##   4、何时使用聚集索引或非聚集索引



下面的表总结了何时使用聚集索引或非聚集索引（很重要）：

 

| 动作描述           | 使用聚集索引 | 使用非聚集索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 小数目的不同值     | 应           | 不应           |
| 大数目的不同值     | 不应         | 应             |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |



  　　事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，**聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。**

##   5、结合实际，谈索引使用的误区

  　　理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。

###   1、主键就是聚集索引

  　　这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。
  　　通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。
  　　显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。
  　　从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为 ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。
  　　在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。
  　　通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。
  　　在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在ID这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。下面我们就来看一下在1000万条数据量的情况下各种查询的速度表现（3个月内的数据为25万条）：

  （1）仅在主键上建立聚集索引，并且不划分时间段：

  Select gid,fariqi,neibuyonghu,title from tgongwen

  用时：128470毫秒（即：128秒）

  （2）在主键上建立聚集索引，在fariq上建立非聚集索引：

  select gid,fariqi,neibuyonghu,title from Tgongwen
  where fariqi> dateadd(day,-90,getdate())

  用时：53763毫秒（54秒）

  （3）将聚合索引建立在日期列（fariqi）上：

  select gid,fariqi,neibuyonghu,title from Tgongwen
  where fariqi> dateadd(day,-90,getdate())

  用时：2423毫秒（2秒）

  　　虽然每条语句提取出来的都是25万条数据，各种情况的差异却是巨大的，特别是将聚集索引建立在日期列时的差异。事实上，如果您的数据库真的有1000 万容量的话，把主键建立在ID列上，就像以上的第1、2种情况，在网页上的表现就是超时，根本就无法显示。这也是我摒弃ID列作为聚集索引的一个最重要的因素。得出以上速度的方法是：在各个select语句前加：

  declare @d datetime
  set @d=getdate()

  并在select语句后加：

  select [语句执行花费时间(毫秒)]=datediff(ms,@d,getdate())

###   2、只要建立索引就能显著提高查询速度

  　　事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。
  　　从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合==建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则==。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。

  3、把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度
  　　上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个**复合索引（compound index）。**
  　　很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）：

  （1）select gid,fariqi,neibuyonghu,title from Tgongwen where fariqi>''2004-5-5''

  查询速度：2513毫秒

  （2）select gid,fariqi,neibuyonghu,title from Tgongwen
  　　　　　　　　　　　　where fariqi>''2004-5-5'' and neibuyonghu=''办公室''

  查询速度：2516毫秒

  （3）select gid,fariqi,neibuyonghu,title from Tgongwen where neibuyonghu=''办公室''

  查询速度：60280毫秒

  　　从以上试验中，我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，**如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。**同时，请记住：==**无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。**==

##   6、其他书上没有的索引使用经验总结

###   1、用聚合索引比用不是聚合索引的主键速度快

  　　下面是实例语句：（都是提取25万条数据）

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=''2004-9-16''

  使用时间：3326毫秒

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen where gid<=250000

  使用时间：4470毫秒

  这里，用聚合索引比用不是聚合索引的主键速度快了近1/4。

###   2、用聚合索引比用一般的主键作order by时速度快，特别是在小数据量情况下

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen order by fariqi

  用时：12936

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen order by gid

  用时：18843

  　　这里，用聚合索引比用一般的主键作order by时，速度快了3/10。事实上，如果数据量很小的话，用聚集索引作为排序列要比使用非聚集索引速度快得明显的多；而数据量如果很大的话，如10万以上，则二者的速度差别不明显。

###   3、使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个：

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi>''2004-1-1''

  用时：6343毫秒（提取100万条）

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi>''2004-6-6''

  用时：3170毫秒（提取50万条）

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen where fariqi=''2004-9-16''

  用时：3326毫秒（和上句的结果一模一样。如果采集的数量一样，那么用大于号和等于号是一样的）

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen
  　　　　　　　　　　　　where fariqi>''2004-1-1'' and fariqi<''2004-6-6''

  用时：3280毫秒

###   4、日期列不会因为有分秒的输入而减慢查询速度

  　　下面的例子中，共有100万条数据，2004年1月1日以后的数据有50万条，但只有两个不同的日期，日期精确到日；之前有数据50万条，有5000个不同的日期，日期精确到秒。

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen
  　　　　　　　　　　where fariqi>''2004-1-1'' order by fariqi

  用时：6390毫秒

  select gid,fariqi,neibuyonghu,reader,title from Tgongwen
  　　　　　　　　　　　　where fariqi<''2004-1-1'' order by fariqi

  用时：6453毫秒

##   7、其他注意事项

  　　“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。
  　　所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。
  　　当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。