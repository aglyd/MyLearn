# 编码：隐匿在计算机软硬件背后的语言

## 第一章、编码

编码概念及作用：指一种用来在机器和人之间传递信息的方式。使用不同的编码来为我们的交流服务。人类的自然交流方式是由人类的器官决定的：口头语言(the spoken word)：听觉信息交流方式（通过嘴和耳朵）；书面语言(the written word)：视觉或触觉信息交流方式（通过眼睛和手摸盲文）。这两种交流方式的实现即是编码：如各种偏旁部首组成的汉语文字，以及不同读音的汉语口语、拉丁字母组成的英语文字、阿拉伯数字表等等

莫尔斯编码：同样属于一种编码方式，只不过是由点和划组成，代变各种不同的涵义（代表不同的字母、数字或标点符号等等）



## 第二章、编码与组合

树形图：可以快速直观全面的列举所有码字，且绝对不会重复。通过此图可以确保我们不会对不同的字母定义相同的码字，其次通过此图我们可以用尽可能短的码字来表示所有的字母，而避免产生编码长度上的浪费。

莫尔斯规范：通过树形图可以快速且准确的制定莫尔斯规范，且能快速解码。

码字书目 = 2^编码的位数

莫尔斯编码又称二进制码（Binary Code）：

组合学：组合分析，对于莫尔斯码码字的组合定义规范的工作属于组合学的组合分析，系数学分支。



## 第三章、布莱叶盲文与二进制码

优先码（precedence codes）/换挡码(shift codes)：数字标识符和字母标识符：相同编码在这两种标识符后面会代表不同含义，代表字母或数字。

逃逸码(escaps codes)：“逃离”对编码串单调的、一成不变的解析，而转入一种新的解码方式中。如大写字母标识符，代表紧跟其后的编码字母应为大写。



## 第四章、手电筒解析

手电筒电报系统

## 第五章、远距离电报系统

负极接地：将整个地球当作公共导线，接入所有负极

距离过长时电阻过大：加电压、扩大导线直径



## 第六章、电报器和继电器

电报器：利用电磁感应，将灯泡换成磁铁，线圈联通开关（发送信息的电键）与电池正极，负极均自行接地，开关闭合会通电，线圈产生磁场将悬挂磁铁吸下来，并发出“滴”的声音，松开开关，磁铁弹回发出“嗒”的声音，一次快速的“嘀嗒”作为点（0），一次慢速“嘀嗒”作为划（1）。

继电器：将上一电路磁铁与下一电路开关导线相连，当上一电路磁铁被吸下来同时闭合了下一电路开关，则自动触发了下一电路信号发送。

类似通信中“放大”信号原理，输入较弱电流，被“放大”成了较强的输出电流。



## 第七章、除十以外的数字系统





## 第十章、逻辑的数学定义

### 1、布尔发明“布尔代数”

类是传统代数，布尔代数也有操作数和算子（+、*等），不同的是，操作数不为数字而是类（class），一个类及一个事物的群体，也称为集合（set）。

算子：“ + ” 表示两个集合的并集；“ * ”表示两个集合的交集。

说明：交换律、结合律和分配律在布尔代数中同样成立，且在布尔代数中，加法还可以来分配乘法，这在传统代数中是不成立的：

例如：W+(B*F) = (W+B) * (W+F)

白猫和黑色母猫的并集=（白猫和黑猫的并集）与（白猫和母猫的并集）的交集。



### 2、布尔代数中的符号0与1

符号1：表示全集，包含了全部元素的集合。如 男人+女人=1，白色+非白色=1。1与减号连用表示排除某类集合：如1 - 男人 = 女人。

符号0：表示空集，不包含任何元素的集合，往往是两个互斥集合的交集。如男人 * 女人 = 0

运算：布尔代数的1和0某些情况下与传统代数的0、1应用一样：

1 * F = F	，所有猫与母猫的交集是母猫的集合。

0 * F = 0	，空集与母猫的集合还是空集。

0 + F = F	，空集与母猫的并集是母猫集合。

但有时也会出现与传统代数相悖的结果：

1 + F = 1	，所有猫与母猫的集合是所有猫集合，这个式子在传统代数中没有意义。

F + (1 - F) = 1		

F * (1 - F) = 0	，F是母猫集合，1 - F是非母猫集合，因此两者并集是全集，而两者交集是空集。

此公式代表了逻辑学上的一个重要概念：矛盾律，即事物不可能是既是它本身，同时又是它的对立面。

F * F = F	，是布尔代数与传统代数形式上最大区别的一个表达式，母猫与母猫的交集还是它本身。

F + F = F	，任何集合和自身的并集还是本身。





-----

## 第二十二章、操作系统

磁盘最开始的两个磁道存储CP/M系统本身,而**CP/M在磁盘上是无法运行的,必须将其加载到内存里**。只读存储器(ROM)在CP/M计算机中使用得并不多,只需要用它来存放一小段称为**引导程序(bootstrap loader,操作系统的其余部分可以通这段代码的自举操作被高效地引导)**的代码即可。开机启动时,磁盘上最开始的128字节的扇区内容,**会首先由引导程序加载到内存并运行,这个扇区包含有特定的代码,可以把CP/M中的其余部分加载到内存中,整个过程称为操作系统的引导(booting)。** 

**控制台命令处理程序(Console Command Processor, CCP)、基本磁盘操作系统(Basic DiskOperating System, BDOS)和基木输入/输出系统( Basic Input/Output System, BIOS)**是CP/M的三个组成部分,这三个部分只占用了6KB大小的内存空间。在拥有64 KB内存空间的计算机中,大约58 KB被临时程序区(Transient Program Area, TPA)占用,但是这58 KB空间一开始时是空的。

BDOS,顾名思义,它的主要功能是维护磁盘上的文件系统。文件系统经常要与终端设备打交道,所以BDOS经常要调用CP/M基本输入/输出系统( Basic Input And Output System, BIOS)中的一些子程序。这里顺便提一下,BIOS可以对硬件进行访问,比如键盘、视频显示器和磁盘驱动器等。实际上,**BIOS是CP/M中唯一需要了解计算机中硬件的程序,其他些对硬件的操作都可通过调用BIOS中的子程序来实现。**控制台命令处理程序通过调用BDOS的子程序来实现自己所有的功能,而在CP/M中运行的程序也是这样。

UNIX操作系统：

在20世纪60-70年代,计算机不仅体积庞大而且价格昂贵,仅仅为一个人服务显然不太现实,为了能够让多个人同时使用计算机,必须有相应操作系统来支持,这也就是开发UNIX系统的最初目的。使用UNIX系统的计算机通过**时分复用(time sharing)技术**一这种技术允许多个用户同时与计算机进行交互一来达到这个目的。计算机连接多个配备了显示器和键盘的终端(terminals),每个用户通过这些终端访问计算机。通过在所有终端间的快速切换,使用户感觉这台计算机似乎只为自己工作,而其实计算机同时在为多个用户服务。



----

## 第二十三章、定点数和浮点数

单精度浮点数和双精度浮点数：如果超过有效数范围，则该值和下一个有效值+1之间的所有数都无法精确显示出来，只能显示为同一数字。

如：单精度有效位23位二进制数，8位指数，1位符号位

16777216和16777217用单精度都显示为前者：1.0000 0000 0000 0000 0000 00*2^24，实际上16777216的完整二进制数为

1.0(24个0)*2^24，但因为有效数只能显示23位，导致最低位再加1则变为了16777218（因为是十位加的1）。

**24位二进制数大致相当于7位十进制，即单精度浮点数精确度约为7位十进制数。**



双精度浮点数：1位符号位，11位指数位，52位有效位

**精度相当于十进制16位**



----

## 第二十四章、高级语言和低级语言

第一个编写汇编器的人需要手工对程序汇编。如果要为机器写一个新的汇编器(或者对其修改),则可以使用汇编语言编写该程序,然后使用原有的汇编器对其汇编。一旦新的汇编器通过了汇编,则它也就可以对自身进行汇编。

每当一种新的微处理器面世,就需要为其编写新的汇编器。然而,新的汇编器可以在已有的计算机上编写,并利用其汇编器进行汇编。这种方式称为**交叉汇编(cross-assembler),即利用计算机A的汇编器对运行在计算机B上的程序汇编。**

虽然汇编器的引入消除了汇编语言编程中重复性的劳动部分(即手动汇编部分),但汇编语言仍然存在两个主要问题。第一个问题(也许你已经意识到了),使用汇编语言编程非常乏味,因为这是在微处理器芯片级的编程,因此不得不考虑每一个微小的细节。**汇编语言存在的第二个问题是不可“移植”(portable)。**如果你为Intel 8080写了一个汇编语言程序,则该程序不能在Motorola 6800上运行,你必须在6800上重写一个相同功能的汇编语言程序。编写类似程序的过程也许没有编写第一个程序那么困难,因为你应经解决了程序的组织和算法问题,但仍然还有很多工作要做。

然而,仅仅定义(define)高级语言,包括定义语言的语法(syntax)来表达该语言可以描述的一切事物,还远远不够;我们还需要为其编写一个**编译器(compiler),编译器可以将高级语言的程序语句转换成机器码指令。**同汇编器类似,编译器也是逐字逐句地读取源文件并将其分解成为短语、符号和数字的,但实现过程要比汇编器更加复杂。**从某些方面来看,汇编器相对简单,因为汇编语言的语句和机器码是一一对应的。而般的高级语言却不具备这种对应关系,编译器通常必须把一条语句转换多个机器码指令。**编译器的编写非常复杂,许多书都是用全部的篇幅来讲解如何设计和构造编译器。

当然,任何事物都是具有两面性的,高级语言也不例外,它有很多优势但也存在不少缺陷。**高级语言最基本的优点在于它比汇编语言易于学习并且更容易编写程序,用高级语言编写的程序通常更加清晰简明**一一**与汇编语言不同,高级语言通常不依赖于特定的处理器,因此它们通常具有良好的可移植性**。因为这种特点,使用高级语言的程序员不再需要关心最终运行程序的计算机的底层结构。当然,如果要在不同类型的处理器上运行程序,则需要用处理器对应的编译器将程序转换成对应的机器码。因此,最后生成的可执行文件仍然只适用于特定的处理器。

另一方面,有一种普遍现象:**一个优秀的汇编程序员所编写的程序比编译器所产生的代码更加有效率。也就是说,从高级语言程序生成的可执行程序比相同功能的汇编语言程序更大,并且运行速度更慢(但从近年的发展来看,这种差别已变得不再明显,因为微处理器变得更加复杂,而且编译器在优化代码方面也更加成熟)。** 

此外,虽然高级语言提高了处理器的易用性,但并没有让其变得更强大。微处理器的任何一个功能都可以通过汇编语言实现,因此汇编语言可以高度利用处理器的功能。**因为高级语言必须转化成机器码,所以它只会降低微处理器的能力。事实上,如果某种高级语言具有真正意义的可移植性,那么它将不能使用某些处理器的特有功能。**例如,许多微处理器都有移位指令。如前所述,这些指令能将累加器中的字节的每位向左或向右移动。但事实上,几乎没有哪一种高级语言包含这种操作。如果在程序中需要进行移位操作,则必须通过乘2或除2来模拟该过程(这并不是什么坏事:事实上,许多现代编译器都是利用处理器的移位指令来实现乘以或除以2的幕的)。除此之外,许多高级语言也不包括按位逻辑运算 。

介绍各种高级语言：

FORTRAN语言（曾广泛用于科学与工程的数字计算语言）、ALGOL高级语言（块结构）、COBOL语言（广泛支持读取记录和生成报表）。

第一个成功地为商务系统所使用的程序设计语言是COBOL ( COmmon BusinessOriented Language),今天它仍然被广泛使用。COBOL 于1959年开始开发,由美国工业界和国防部组成的委员会发起并实施,它的设计思路受到格瑞斯,霍珀早期编译器的影响。从某些方面来看,COBOL的设计中渗透了这种思想:使管理人员--可能并不进行实际的编码工作--但他们至少可以看懂程序代码,而且能够检测程序能否完成预定工作(实际上这种情况非常少见)。

COBOL 语言广泛支持读取记录(record)和生成报表(report)。记录是按照统一方式归类整理的信息的集合。例如,保险公司一般会维护一个包括其所售的所有保险信息的大型文件,每一项保险业务称为一条单独的记录。每一条记录包括客户的姓名、出生日期等信息。早期编写的COBOL程序,大都是为了处理存储在IBM打孔卡片上的80列记录而编写的。为了尽量减少孔洞所占用的卡片空间,年份通常设计成2位而不是4位,随着时间的推移,这个设计的缺陷逐渐显露出来,最终导致在2000年出现了著名的“干年虫问题” (millennium bug)

BASIC语言：很多BASIC的后续版本都是**解释型(interpreter)而不是编译型(compiler)**。如前所述,**编译器读取源文件并生成一个可执行文件;而解释器却采取边读边执行的方式,不会产生新的文件。解释器比编译器的原理简单一些,因此更容易编写,但其运行程序的速度要比后者要慢。（PS：但是启动速度快）**BASIC语言应用于家用计算机的时间较晚,1975年,比尔·盖茨(BillGates,生于1955年)和其好友保罗·艾伦(Paul Allen,生于1953年)为Altair 8800编写了BASIC解释器,这一事件可以视为BASIC在此领域的开端,同一年他们创建了微软公司(Microsoft Corporation )。

Pascal 程序设计语言继承了ALGOL的大部分结构,同时还继承了COBOL的记录处理功能,它由瑞士计算机科学教授尼尔莱斯·沃思(Niklaus Wirth,生于1934年)在20世纪60年代末开发完成。IBM PC的程序员对Pascal非常青昧,而备受欢迎Pascal版本却是大名鼎鼎的Turbo Pascal。 1983年,宝兰公司(Borland International)发布了TurboPascal,当时的售价是49.95美元。Turbo Pascal由一名叫安德斯·海尔斯伯格(AndersHejlsberg,生于1960年)的丹麦大学生开发,它提供了完整的集成化开发环境(integrateddevelopment environment )。**程序的文本编辑器和编译器集成在一起**,这样就方便了程序的调试和运行,大大加快了程序开发速度。集成化开发环境以前主要用于大型计算机,TurboPascal实现了在小型计算机上的突破。

C语言：人们常常对为什么以C来命名该语言感兴趣,答案其实很简单,它是一种早期的程序设计语言B的后继者。B是BCPL (Basic CPL)语言的一种精简版本,而BCPL来源于CPL( Combined Programming Language )。如第22章所述,UNIX操作系统在设计的过程中充分考虑到了可移植性。**当时的许多操作系统都是基于某种处理器的,并且使用汇编语言编写,基本上没有可移植性可言。1973年, UNIX采用C语言编写(更准确地说,应该是重写)成功,**从此以后UNIX操作系统和C语言就变得密不可分了。

在本章的前面曾讲过,很多高级语言都不支持移位操作和按位布尔运算操作,而许多处理器其实支持这类操作,C语言打破了这种局限,它广泛地支持这类运算。除此之外,C语言的另一重要特征是对于**指针(pointer)的支持,指针本质是数字化描述的内存地址。C语言中的很多操作与通用处理器的指令非常相似**,因此**C也被称为高级汇编语言( high-level assembly language)。**与类 ALGOL 语言相比, C的操作集与通用处理器的指令集接近程度更高,或者说远胜过它们。



----

## 第二十五章、图形化革命

键盘和CRT一起对远程计算机传输来的ASCII码(可能还包括Escape字符序列)做出响应,这种设备我们称之为哑终端(dumbterminal)。

IBM早期PC配备的应用程序通常只有字符输出,很少有图形输出。使用文本输出大大加快了应用程序的运行速度。假设PC上配备一台第21章所描述的视频显示器,那么程序所要做的就是把字符相应的ASCI码写入内存,然后屏幕上就会显示出该字符。但是如果使用的是图形视频显示设备,那么相应的程序需要将8个或更多的字节写入到内存中,这样做的目的就是画出字符的外观并以图形的方式显示。

计算机图形也逐步产生了两种分支一本章的前面曾提到过这两个词,当时是为了区分图形视频显示器 一这两个分支就是**矢量和光栅**。**矢量图形(vector graphics )**在一些算法的帮助下,利用直线、曲线及填充区域生成图形。这也正是计算机辅助设计(Computer-Assisted Drawing, CAD)所应用的领域。矢量图形在工程和体系结构设计中有着十分重要的作用。**矢量图形一般转化为图元文件(metafile )格式以存放到文件中。图元文件是由生成矢量图形的一系列绘制命令的集合组成的,**这些命令通常已经被编码为二进制形式。矢量图形的主要工具就是直线、曲线及填充区域。如果你想设计桥梁,使用矢量图形来实现将很简单,但如果要显示桥梁的实际结构,矢量图形就显得无能为力了。对于现实世界里的一副桥梁的整体结构图,用矢量图形来表示将会很复杂,而且困难重重。

**光栅图形(也称做位图)**,就是为了解决这一问题应运而生的。位图(bitmap)将图像以矩阵阵列的形式进行编码,阵列中的一个单位对应着输出设备上的一个像素点。就像视频显示器一样,位图是一种空间上的概念(可以称其具有分辨率),其图像的宽度和高度都以像素为单位来表示。位图也具备色深(也可叫做颜色分辨率/颜色深度)的概念色深是指每一个像素被赋予的比特数。位图中每个像素被赋予的比特数相同 

位图文件可能很大,如果有方法可以让它们变小一些那就再好不过了。这种需求催生了计算机科学中的**数据压缩(**Data Compression)这一全新领域。假设我们正在处理一幅每个像素占3位的图像,这种图像在本章前面曾讲过。这张图片上出现的画面是一片天空、一栋房子和一块草坪。因此,图片中可能有大片的蓝色和绿色。很可能位图的最上面一行出现了72个蓝色像素。如果有一种方法可以表示蓝色 

像素连续且重复了72次,那么通过这种方法表示的位图文件将会比原先的小很多。这样的压缩方法称为**游程长度编码(Run-Length Encoding),即RLE。**通常办公室的传真机采用的就是RLE压缩方法,压缩过程一般在传真机通过电话线传送图像之前。由于传真机展现出的图片都是黑白两色,没有灰度和彩色,所以通常像素值都会有很长串的白色区域,适合使用RLE压缩。这十多年里风光无限的位图文件格式是图形交换格式(Graphics Interchange Format)即GIF,由计算服务(CompuServe)公司于1987年开发。**GIF文件所采用的压缩技术称为LZW,** LZW源自其三位创建者的名字: Lemplel、Ziv和Welch。 LZW比RLE更加强大,因为它所考虑的是**像素值的模式(patterns),而RLE针对的是具有相同值的像素串。**RLE 和LZW都属**无损(lossless)压缩技术范畴**,因为可以从压缩数据中重新生成完整的初始文件。专业一点的说法是,**压缩过程是可逆的(reversible)。可逆压缩方法并不适用于所有类型的文件**,这点不难证明。在某些情况下,采用这些方法“压缩”后的文件比初始文件还要大。

近几年来看**,有损(lossy)压缩技术**大行其道。有损失的压缩是不可逆的,这是由于部分原始数据在压缩过程中被丢弃了。有损压缩技术不应该用于电子报表或文字处理文档,因为在这些重要文档里面少一个数字或者字母都会“失之毫厘,谬以千里”。但对于压缩图像,这些损失还是可以接受的,部分数据的损失不会使图片的整体效果有太大的变化。这就是为什么有损压缩技术的思想起源于心理视觉的原因,心理视觉领域所探究的是人的视觉,并根据心理因素确定人们所看到的景象中哪些比较重要而哪些不重要。在JPEG中,人们使用了一系列具有重大意义的位图有损压缩技术,。**JPEG代表的是联合图像专家组(Joint Photography Experts Group),它涵盖了几种压缩技术,其中一些是无损的,另一些是有损的。** 

把图元文件（矢量图形）转换成位图文件的方法很简单。这是由于视频显示存储器与位图在概念上保持一致。如果程序能把图元文件画在视频显示存储器中,则它也能在位图上画出图元文件。但从位图文件到图元文件的转换却不那么容易,如果位图文件过于复杂甚至会导致无法转换。为了解决此类问题,人们发明了一项技术,那就是**光学字符识别(Optical Character Recognition ),或简称为 OCR。**对于位图上出现的一些字符(来自于传真机,或来自于页面扫描),如果需要转换成ASCII码,那么OCR就会派上用场。**OCR软件会对比特流进行模式识别,然后确定其代表的字符。**由于算法的复杂性, OCR软件并不能保证百分之百准确。虽然不很准确,但是**OCR软件一直尝试将手写的字符也转换成ASCI码字符。**

代表声音的电流与先前所讲过信号不同,本书之前讨论过的是在“连通一断开”之间跳变的1/0数字信号。声波的变化是连续的,因而产生电流的电压也是如此。在这里电流产生的目的是模拟(analog)声波。为了达到这个目的,我们使用了一种新设备,通常把它叫做模拟数字转换器(Analog To Digital Converter, ADC)-所有的功能集成在了一个芯片上一将模拟电压转换成二进制数表示。一定长度的数字信号将会被ADC所输出-一通常长度为8、12或16个比特-一它们组合在一起表明了电压的相对级别。如果 ADC的转化长度为12比特,那么电压值的取值范围为000h~FFFh,这样一来就可以区分出4096个不同的电压级别。 

在一种名为**脉冲编码调制(Pulse Code Modulation)**的技术中,以电压形式表示的声波将以恒定的频率被转换成数值。而这些数值将以小孔的形式刻在光盘表面,通过这种方式,电压就以数值的形式被存储在CD上。要读取这些信息时,可以通过分析从CD表面反射的激光读取到所存储的数值。在播放声音的时候这些数值又被转换成电流,这一过程利用到了**数字模拟转换器(Digital-To-Analog converter,即DAC, DAC 还可以用在彩色图形板上,将像素值转换成模拟信号并传输至显示器)**。声波电压在恒定的频率下被转换成了数字,该频率被称为**采样率(sampling rate)**。1928年,贝尔电话实验室的哈里,奈奎斯特(Harry Nyquist)通过证明得到了一个总要结论:采样频率应至少为被采样信号(即被记录和播放的信号)最大频率的两倍。人类可以听到的声音的频率范围通常为20~20,000Hz。CD使用的采样频率为每秒44,100次,比人类听觉范围最大频率的两倍还要大一些。 

电话系统在线路上传输的是声音,而不是比特。在电话线路上传输比特需要先将其转换成声音,传输完之后在转换回比特。单一频率和振幅的连续声波(统称为载波,carrier) 无法表达完整清晰的信息。但如果对声波进行一些调整-说得专业一点就是,对声波进行**调制(modulate)**使其反映两种不同的状态--通过这种方式可以表示出0和1。**将比特与声波进行互相转换的设备被称做调制解调器(modem,它包括调制和解调两个功能)。调制解调器以串口(serial)形式工作,因为字节中的单个比特是一个接一个传输的**,而不是一拥而上(打印机一般通过并行接口与计算机相连:整个字节由8根线并行传输)。早期调制解调器采用了**频移键控(frequency-shift keying, FSK)技术**。假设调制解调器的处理速度为300 bps,而且二进制数0被调制到1070 Hz,而1被调制到1270Hz。每个字节被夹在一个起始位和一个停止位中间,所以每个字节其实占据了10位空间。在300bps的传输速率下,每秒传输的字节数为30个。现在许多采用先进技术的新一代调制解调器速度超过了它的100   倍 。

Internet与这些早期的发明有本质上的差别,因为它是一种非中心化的系统。Internet从本质上来讲是一组协议的集合,这些协议是计算机之间相互通信的保证。众多的协议中,最重要的当属TCP/IP协议,它包括了**传输控制协议(Transmission Control Protocol,TCP)和网际协议(Internet Protocol, IP)。**这种协议使得传输过程变得规则化,不再是简单地通过线路传输ASCII码字符,而由基于TCP/IP协议的传输系统把大的数据块分割成小的包(packets),之后在传输线路上(通常是在电话线上)独立发送,最后在传输线路的另一端将数据重新组装起来。

Internet中最流行的是万维网( World Wide Web),而这一部分与图形联系最紧密。万维网采用了HTTP协议来支持其工作, HTTP (Hypertext Transfer Protocol)即超文本传输协议。几乎所有在Web页面上看到的数据都遵循一定格式,那就是HTML (HypertextMarkup Language),即超文本标记语言。其中超文本(hypertext)这个单词用来描述相关链接信息,非常类似于万·布什预言的麦克斯储存器。HTML文件可以包含指向其他Web页面的链接,这样可以轻松访问其他页面。 

Java是一款成熟的面向对象程序设计语言,和CHH有些类似。前面章节中我们讨论过**编译语言(compiled languages,可产生包含机器码的可执行文件的语言)和解释语言(不可产生可执行文件的语言)之间的区别,Java是一种介于两者之间的语言。它需要经过编译,但编译的结果不是机器码,而是Java字节码(Java byte codes )。** **Java字节码与机器码在结构上很相似,但Java字节码可以在一种虚拟的计算机下被解释,即Java虚拟机( Java VirtualMachine, JVM)上。被编译的Java程序产生Java字节码,之后计算机模拟JVM对其进行解释。Java程序的运行可以不受限于机器与图形操作系统的类型,所以它具有平台无关性(platform- independent )。**
