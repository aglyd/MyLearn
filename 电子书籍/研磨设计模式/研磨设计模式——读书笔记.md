# 研磨设计模式——读书笔记

## 1、简单工厂

![img_77](../研磨设计模式_files/img_77.png)

![img_79](../研磨设计模式_files/img_79.png)

![img_81](../研磨设计模式_files/img_81.png)

![img_83](../研磨设计模式_files/img_83.png)



![img_85](../研磨设计模式_files/img_85.png)

![img_87](../研磨设计模式_files/img_87.png)

## 2、外观模式

![img_113](../研磨设计模式_files/img_113.png)

![img_115](../研磨设计模式_files/img_115.png)

==缺省实现：默认实现，如果子系统是分成各个子模块去开发的，而又不用外观模式使用一个默认实现（方法）去简化为一个统一的接口去调用的话，就得客户端亲自调用各个子系统的子模块，使子系统内部暴露==

<img src="../研磨设计模式_files/img_121.png" alt="img_121" style="zoom:50%;" />

<img src="../研磨设计模式_files/img_123.png" alt="img_123" style="zoom: 50%;" />

<img src="../研磨设计模式_files/img_125.png" alt="img_125" style="zoom: 33%;" />



## 3、适配器模式

![img_151](../研磨设计模式_files/img_153.png)

![img_153](../研磨设计模式_files/img_153.png)

![img_155](../研磨设计模式_files/img_155.png)

![img_157](../研磨设计模式_files/img_157.png)

==缺省适配：创建适配器实例时构造器不传操作实例对象参数，在要使用某一个操作对象时再选择传入某一个操作实例进入==



![img_159](../研磨设计模式_files/img_159.png)

![img_161](../研磨设计模式_files/img_161.png)

![img_163](../研磨设计模式_files/img_163.png)

![img_165](../研磨设计模式_files/img_165.png)

==双向适配：适配器既可以使用原有操作实例方法（使用传入的操作对象原方法），又可以使用旧客户端使用第二版的接口方法（适配器类重写反转调用）==

![img_171](../研磨设计模式_files/img_171.png)

![img_173](../研磨设计模式_files/img_173.png)

==若要适配很多同父类的子类时，适配器可组合父类对象引用，传入子类对象进行适配==

![img_175](../研磨设计模式_files/img_175.png)

## 4、单例模式

![img_197](../研磨设计模式_files/img_197.png)

[相关资料][https://blog.csdn.net/javazejian/article/details/73413292]：==JVM中表示两个class对象是否为同一个类对象存在两个必要条件==

==类的完整类名必须一致，包括包名。==
==加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。==
==也就是说，在JVM中，即使这个两个类对象(class对象)来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的，这是因为不同的ClassLoader实例对象都拥有不同的独立的类名称空间，所以加载的class对象也会存在不同的类名空间中，但前提是覆写loadclass方法==



![img_199](../研磨设计模式_files/img_199.png)

![img_201](../研磨设计模式_files/img_201.png)

![img_203](../研磨设计模式_files/img_203.png)

==static性质==

![img_207](../研磨设计模式_files/img_207.png)

![img_211](../研磨设计模式_files/img_211.png)

==利用缓存来控制创建单例类创建的实例个数==

![img_213](../研磨设计模式_files/img_213.png)

![img_215](../研磨设计模式_files/img_215.png)

![img_217](../研磨设计模式_files/img_217.png)

**通过volatile修饰的变量，不会被线程本地缓存，所有线程对该对象的读写都会第一时间同步到主内存，从而保证多个线程间该对象的准确性 **。防止A线程创建了单例实例后未同步到共享主内存，但是指针变量又不为空了（A创建实例对象未完全完成），其他线程调用实例对象时会空指针

**volatile的作用**

- 防止指令重排序，因为instance = new Singleton()不是原子操作
- 保证内存可见（保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的）
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作

![img_219](../研磨设计模式_files/img_219.png)

![img_221](../研磨设计模式_files/img_221.png)

![img_223](../研磨设计模式_files/img_223.png)

![img_225](../研磨设计模式_files/img_225.png)

==至于如何调度哪个对象暂时未作讨论，此处缓存单例使用的懒汉式未处理线程不安全问题==





## 5、工厂方法模式



![img_239](../研磨设计模式_files/img_239.png)

![img_241](../研磨设计模式_files/img_241.png)

![105](研磨设计模式——读书笔记.assets/105.png)

### 1、认识工厂方法模式

![img_249](../研磨设计模式_files/img_249.png)

![img_251](../研磨设计模式_files/img_251.png)

==一搬工厂方法返回被创建对象的高级抽象类==

![img_253](../研磨设计模式_files/img_253.png)

==一种客户端使用工厂方法完成功能（创建的对象用于工厂内部方法调用）==

==另一种工厂创建对象直接返回给客户端使用==

![img_255](../研磨设计模式_files/img_255.png)



### 2、工厂方法模式与Ioc/DI

![img_257](../研磨设计模式_files/img_257.png)

![img_259](../研磨设计模式_files/img_259.png)

![img_261](../研磨设计模式_files/img_261.png)

![img_263](../研磨设计模式_files/img_263.png)

### 3、平行的类层次结构

![img_265](../研磨设计模式_files/img_265.png)

==不同的行为对象共用同一个硬盘对象，解耦行为对象实现复用==



### 4、参数化工厂方法

![img_267](../研磨设计模式_files/img_267.png)

![img_269](../研磨设计模式_files/img_269.png)

![img_271](../研磨设计模式_files/img_271.png)

![img_273](../研磨设计模式_files/img_273.png)

### 5、工厂方法模式的优缺点

![img_275](../研磨设计模式_files/img_275.png)

![img_277](../研磨设计模式_files/img_277.png)

![img_279](../研磨设计模式_files/img_279.png)



## 6、抽象工厂模式

![img_297](../研磨设计模式_files/img_297.png)

![img_299](../研磨设计模式_files/img_299.png)

![img_301](../研磨设计模式_files/img_301.png)

![img_305](../研磨设计模式_files/img_305.png)

![img_307](../研磨设计模式_files/img_307.png)

![img_313](../研磨设计模式_files/img_313.png)

==工厂方法模式和抽象工厂模式是类似的，实现方式相同，只是抽象工厂是创建一个产品族，当抽象工厂里只创建一个产品时，该工厂就退化为了工厂方法模式了==



![img_315](../研磨设计模式_files/img_315.png)

![img_317](../研磨设计模式_files/img_317.png)

![img_317](../研磨设计模式_files/img_317.png)

![img_321](../研磨设计模式_files/img_321.png)

![img_323](../研磨设计模式_files/img_323.png)

![img_325](../研磨设计模式_files/img_325.png)

![img_327](../研磨设计模式_files/img_327.png)

![img_329](../研磨设计模式_files/img_329.png)

![img_335](../研磨设计模式_files/img_335.png)

![img_337](../研磨设计模式_files/img_337.png)