# [Java对象锁的理解](https://blog.csdn.net/m0_50370837/article/details/124341972)

## Java的锁机制

以前理解Java的[锁机制](https://so.csdn.net/so/search?q=锁机制&spm=1001.2101.3001.7020)认为：锁的类型分为**‘类锁’，’方法锁‘，’对象锁‘。**

1. 类锁(synchronized(静态对象))：类的所有对象都要竞争锁。
2. 方法锁(在方法前加synchronized)： ~~同一对象同一方法需要竞争锁。~~同一对象即使是不同的方法，只要加了 synchronized都会阻塞。
3. 对象锁(synchronized(对象))：同一对象代码块竞争锁。

**以上都是在学习Java锁的基础理解**

**其实上面所有的锁，都是“对象锁”, 为什么这么说呢?**

**类锁：** (错误)什么是静态变量对象？ **被方法区引用着的对象，不会被GC回收。**
（改正）后来从书中发现，**锁的是该对象的Class对象**
**方法锁：** 在方法前面加上synchronized后，线程进入该方法时会获得**该方法所属对象**的锁，也是对象锁。

## JVM锁的分类

在JVM中，根据锁的优化分为三种锁，**偏向锁、轻量级锁、重量级锁**，线程竞争越激烈，使用的锁等级越高，锁的转换过程不可逆，无法降级。

**1. 偏向锁**
乐观锁。对象头有一个标志 MarkWord 负责记录哪个线程获得了锁，如果已经记录了线程A，线程A可以直接进入，但是线程B进入时，会检测线程A是否活动。
不活动：把标志MarkWord指向自己B。然后进入同步代码块。
活动：等待线程A执行到安全点，挂起线程A。执行线程B。最后膨胀为轻量级锁。

**2. 轻量级锁**
乐观锁。升级轻量级锁后，线程A获得锁时，会在线程A的栈帧中创建“lock record”来记录(复制)对象头的MarkWord,并将对象头的MarkWord 更新为指向“lock record”的指针。如果更新失败了就会自旋有限次数，仍然失败就会膨胀为重量级锁。

**3. 重量级锁**
悲观锁。如果线程A获取了对象的锁，其它线程会自旋有限次数，失败后线程B被阻塞挂起。线程A释放锁后唤醒所有阻塞的线程，一起竞争对象锁。阻塞线程之间不会排队等待，没有”先到先得“的原则。
