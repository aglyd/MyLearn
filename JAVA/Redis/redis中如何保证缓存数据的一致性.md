# [redis中如何保证缓存数据的一致性](https://www.cnblogs.com/aaaazzzz/p/13424287.html)



## 1.方式一：先更新数据库，再更新缓存场景

当有两个线程A、B，同时对一条数据进行操作，一开始数据库和redis的数据都为tony，当线程A去修改数据库，将tong改为allen，然后线程A在修改缓存中的数据，可能因为网络原因出现延迟，这个时候线程B，将数据修改成了Mike、然后将数据库中的tony，也改成了Mike，然后线程A恢复正常，将redis中的缓存改成了allen，此时就出现了缓存数据和数据库数据不一致情况。不推荐

![img](https://img-blog.csdnimg.cn/20191104222321245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)

## 2.方式二：先更新缓存，再更新数据库场景

当有两个线程A、B，同时对一条数据进行操作，线程A先将redis中 的数据修改为了allen，然后CPU切换到了线程B，将redis中的数据修改为了mike，然后将数据库中的信息也修改了mike，然后线程A获得CPU执行，将数据库中的信息改为了allen，此时出现缓存和数据库数据不一致情况。不推荐

![img](https://img-blog.csdnimg.cn/20191104222348856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)

## 3.方式三：先删除缓存，再更新数据库的场景

当有两个线程A、B，同时对一条数据进行操作，当线程A进行修改缓存操作时，先删除掉缓存中的数据，然后去修改数据库，因为网络问题出现延迟，这时线程B需要去数据库中查询数据为tony，然后将数据更新到缓存中，线程A网络恢复，又将数据库数据修改为了allen，此时出现数据不一致。不推荐

![img](https://img-blog.csdnimg.cn/20191104222412959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)

## 4.方式四：先更新数据库，在删除缓存场景

*一改一查场景：*

当有两个线程A、B，线程A先去将数据库的值修改为allen，然后需要去删除redis中的缓存，当线程B去读取缓存时，线程A已经完成delete操作时，缓存不命中，需要去查询数据库，然后在更新缓存，数据一致性；如果线程A没有完成delete操作，线程B直接命中，返回的数据与数据库中的数据不一致，可能会短暂出现数据不一致情况，但最终都会一致。推荐

*存在的问题：当数据过期或者初始化时，会出现数据不一致情况，也就是线程B从数据库中，查询到数据为tony，然后线程A将tony修改为了allen，然后去删除redis中的数据，然后线程B将读到的tony，更新到了数据库中，出现了数据不一致问题。*

*解决方案：对于不过期的数据我们要在上线的时候做好数据的预热，保证缓存命中。对于存在过期的数据，因为有过期时间，只会在特定的时间段内数据不一致，下次数据过期后，可以恢复，对于实时性要求不高时，可以接受。*==**(更新数据库成功，删除缓存失败改进：删除缓存加入队列，重试机制再次删除，见下文)**==

![img](https://img-blog.csdnimg.cn/20191104222450681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)

*两次修改场景：*

当有两个线程A、B，线程A去修改数据库中的值改为allen，然后出现网络波动，线程B将数库中的值修改为了Mike，然后两个线程都会删除缓存，保证数据一致性。

![img](https://img-blog.csdnimg.cn/20191104222525653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)

## 5.方式五：最佳实现，数据异步同步

Canal：基于数据库增量日志解析，提供增量数据订阅和消费https://github.com/alibaba/canal

mysql会将操作记录在Binary log日志中，通过canal去监听数据库日志二进制文件，解析log日志，同步到redis中进行增删改操作。

canal的工作原理：canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议；MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )；canal 解析 binary log 对象(原始为 byte 流)。

![img](https://img-blog.csdnimg.cn/20191104222554115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhb2RvbmcxOTk0,size_16,color_FFFFFF,t_70)



----------------



# 被 leeder 摆了一道，哭笑不得！

## 前情回顾

上回程序员阿旺为了提升数据访问的性能，引入 Redis 作为 MySQL 缓存层，但是这件事情并不是那么简单，因为还要考虑 Redis 和 MySQL 双写一致性的问题。

阿旺经过一番周折，最终选用了「**先更新数据库，再删缓存**」的策略，原因是这个策略即使在并发读写时，也能最大程度保证数据一致性。

聪明的阿旺还搞了个兜底的方案，就是给缓存加上了过期时间。

本以为就这样不会在出现数据一致性的问题，结果将功能上线后，老板还是收到用户的投诉「说自己明明更新了数据，但是数据要过一段时间才生效」，客户接受不了。

老板转告给了阿旺，阿旺得知又有 Bug 就更慌了，立马就登录服务器去排查问题，查看日志后得知了原因。

「先更新数据库， 再删除缓存」其实是两个操作，这次客户投诉的问题就在于，**在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值**。

好在之前给缓存加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。

所以新的问题来了，**如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？**

阿旺分析出问题后，慌慌张张的向老板汇报了问题。

老板知道事情后，又给了阿旺几天来解决这个问题，画饼的事情这次没有再提了。

- 阿旺会用什么方式来解决这个问题呢？
- 老板画的饼事情，能否兑现给阿旺呢？

## 如何保证两个操作都能执行成功？

这次用户的投诉是因为在删除缓存（第二个操作）的时候失败了，导致缓存还是旧值，而数据库是最新值，造成数据库和缓存数据不一致的问题，会对敏感业务造成影响。

举个例子，来说明下。

应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfe0mIAy1O09Jp9ZgFSz9siaDoFSr8SXJ42R0muFan6LgCwsfzhK5bvDTqR86SoxLvZibk2PKFTiaicpw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有 诶删除，所以会缓存命中，但是读到的却是旧值 1。

其实不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。

问题原因知道了，该怎么解决呢？有两种方法：

- 重试机制。
- 订阅 MySQL binlog，再操作缓存。

先来说第一种。

### 重试机制

我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。

- 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

举个例子，来说明重试机制的过程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfe0mIAy1O09Jp9ZgFSz9siaznh4xhY7cuGIdbThic6g966OdKRqzBqCK82rh72nBeuaYciaH7Bv8wIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 订阅 MySQL binlog，再操作缓存

「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。

于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。

Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。

下图是 Canal 的工作原理：

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfe0mIAy1O09Jp9ZgFSz9siaOWVfNgt7QqpCFTu6BXLTQkrIBfjh23dFTYVf5KklesYjiaW9EPpfW5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

所以，**如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。**



----------



## 总结：导致redis与数据库数据不一致的原因有两个：

1. **更新缓存失败**
2. **高并发导致更新缓存和更新DB操作之间存在误差**



### 1、更新缓存失败

**（1）先更新DB后操作（更新/删除）缓存情况下，可以加入重试机制让redis再次异步操作缓存，方法有如下：**

- 使用**消息队列**（如JVM队列、MQ队列）
- 订阅MySQL binlog



**（2）若是先操作（更新/删除）缓存后更新DB情况下，若删除缓存失败则不再继续db操作**

### 2、并发高

当高并发情况下，在如下策略时会导致数据不一致：

#### (1)、先删除缓存，后更新数据库

问题：若A线程已完成删除缓存，还没来得及更新数据库，此时B线程来查询数据库后更新了旧数据到缓存（如果设置了缓存过期，则在过期时间内会数据不一致），A再完成数据库更新。

![img](https://img2018.cnblogs.com/blog/882980/201912/882980-20191224155126705-1996892852.png)

改进方案：

针对这种情况，可以先把“修改DB”的操作放到一个JVM队列，后面读请求过来之后，“更新redis缓存”的操作也放进同一个JVM队列,每个队列，对于一个作业线程，按照队列的顺序，依次执行相关操作，这样就可以保证“更新缓存”一定是在DB修改之后，以保证数据一致性，具体如下图所示：

 ![img](https://img2018.cnblogs.com/blog/882980/201912/882980-20191224155146370-1683783902.png)

 

 

细想该方案，其实还有几个优化点

1、读请求过多的时候，队列里面会有多个“更新缓存”操作串在一起，其实是没有意义的，往队列里面塞数据的时候可以先判断一下，有的话就不用再塞进去了

 ![img](https://img2018.cnblogs.com/blog/882980/201912/882980-20191224155207510-1406117894.png)

 

 

2、遇到更新DB比较频繁的业务场景时，可能会导致读请求长时间阻塞，这个时候可以通过扩机器增加吞吐量，或者可以先返回一个旧的值。

![img](https://img2018.cnblogs.com/blog/882980/201912/882980-20191224155221682-1512009367.png)

#### (2)、先更新数据库，后更新缓存

问题：A当更新完了数据库，还没来得及更新缓存，此时B再更新了数据库和缓存，A再次去更新redis了为自己的旧值（数据库中已为B的新值）。



改进方案：

将更新缓存操作加入到消息队列中，A先更新先加入，B后更新后加入

> 注：改进后的此方案与｀先更新DB后删除缓存｀方案相比，**相同点都是将操作缓存操作加入到消息队列中**，区别点在于一个是删除操作一个是更新操作，相比之下删除的方案会更优，因为当有多个删除缓存操作要加入队列中时可以控制只加入一个删除操作就行，等到要查询数据时再更新缓存（达到缓存懒加载效果）。而更新的方案却需要所有更新操作都加入队列依次执行，而且还只有最后一个更新操作才是有效操作（若是加入新更新操作之前能删除队列中旧的更新操作，也能达到效果，若是不要求立即更新缓存这样做就是浪费性能）。**因此，若是不要求更新DB之后立即更新缓存（一般没有这种需求，实时性特别高，每次查询时候都不能等到再去查一次db），则｀先更新DB后删除缓存｀方案性能更优。**





#### (３)、先更新缓存，后更新数据库

问题描述见上文



改进方案：

先写入redis的缓存，就直接返回；定期或特定动作将数据保存到mysql或消息队列，可以做到多次更新，一次保存；但是**注意必须要更新缓存的同时将更新ｄｂ操作按顺序记录下来（或加入队列）**，这样才能保证更新ｄｂ的操作顺序是和更新缓存操作顺序是保持一致的。



> **总结：”先更新数据库后删除缓存“　优化方案更多将压力放在数据库服务器上，不适合ｄｂ频繁的业务场景。”先更新缓存，后更新数据库“　优化方案更多将压力放在后台服务器上要更新ｒｅｄｉｓ与将更新ｄｂ加入队列做出原子性操作，适合ｄｂ频繁场景，如果ｄｂ操作不是很频繁，此操作就是浪费性能。注：所有方案都要设置缓存有效期（具体时效根据业务实时性决定）**

