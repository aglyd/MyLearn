# [Java集合和数组](https://www.csdn.net/tags/Mtjakg3sNjM3MzktYmxvZwO0O0OO0O0O.html)

**什么是集合和数组呢**

集合和数组都是对多个数据进行存储操作的及格，简称Java容器

它们两个有什么区别呢？集合可以存放不同类型的数据，而数组只可以存放定义好的数据类型的数据。

**数组的特点**

数组是具有相同的数据类型按一定次序排序的一组变量的组合体。

对于静态数组来说，一旦初始化以后，长度就确定了。只能操作定义好的数据类型的数据，比如String[],int[]。

**数组的缺点**

对于添加删除插入等操作，最坏的结果是O（N），效率非常低，因为数组在内存中的地址是连续相邻的，每次删除元素，都要移动改元素后面的位置。

复习题：为什么数组比**链表**查询的速度更快？(注意不是说ArrayList)

从内存分配来看，数组是连续的内存地址，而链表的节点是分散在堆空间里的。

从寻址操作次数来看，数组只需知道基地址和要查询的下标索引，加上数组的数据类型的元素大小，根据 [基地址+元素大小*k] 就能找到第k+1个元素的地址 ， 链表要获得第k个元素，首先要在其第k-1个元素寻找到其next指针偏移，再将next指针作为地址获得值，这样就要从第一个元素找起，多了多步寻址操作，当数据量大且其它操作较少时，这就有差距了。



------



# [Java集合和数组的区别、选⽤及其原因](https://wenku.baidu.com/view/8424cebf52e79b89680203d8ce2f0066f5336429.html)

集合

(Collection)

和数组

(Array)

## ⼀、集合和数组的区别

区别1：

- 数组既可以存储基本数据类型，⼜可以存储引⽤数据类型，基本数据类型存储的是值，引⽤数据类型存储的是地址值。
- 集合只能存储引⽤数据类型（对象）。集合也能存储基本数据类型(有点⽭盾，看后句)，但是在存储的时候会**⾃动装箱变成对象**

区别2：

- 数组长度是固定的，不能⾃动增长。
- 集合的长度是可变的，可以根据元素的增长⽽增长。

## ⼆、集合和数组什么时候⽤

 1、如果元素个数是固定的推荐⽤数组，效率⾼。

 2、如果元素个数不是固定的推荐⽤集合

## 三、集合和数组什么时候⽤的原因

 部分集合内部是⽤数组实现（当然还有是哈希，⼆叉树等），当每次创建⼀个集合对象是，默认创建10个长度的数组。当添加到第11

个时，它会按照原数组1.5倍创建，在把原来的数组值复制过去，原来10长度的数组将变成垃圾被回收。当添加到16或者更多，以后都是

按照原数组1.5倍创建，复制这个过程。所以，**==当固定长度为100的时候，你选择了集合就是低效率，选择数组就是⾼效率，因为集合⾥⾯有很多创建，复制，销毁过程。==**



------

# [Java数组集合性能优化](https://wenku.baidu.com/view/6cf5eb63b007e87101f69e3143323968011cf4ab.html)

## 1、 复制数组元素，使⽤System类arraycopy()⽅法替代循环赋值在数组之间复制元素

建议：System类arraycopy()⽅法复制数组元素

杜绝：循环赋值复制数组元素

原因： System类arraycopy()⽅法调⽤操作系统更底层函数，效率更⾼。

注：通过实测，在元素数量达到亿级别，两者都在⼏百毫秒，都很快，System类arraycopy()⽐循环赋值性能仅快1倍，但仍推荐使⽤

System类arraycopy()。

## 2、避免创建集合不设置初始容量

使⽤集合(List、Set、Map)存储⼤量的对象

建议：先估计存储的元素个数，然后在创建集合时设置集合的容量值要⼤于估计的元素个数。

杜绝：未设置集合容量值

原因：创建集合对象，如果未设置集合初始容量值，则使⽤默认值，⽽默认值都很⼩(如，ArrayList的初始容量为10)，⼀旦存储的元素个

数超过阈值，会造成集合扩容。扩容⽅式是根据扩容因⼦创建⼀个新的集合对象(初始容量=原有集合容量*扩容因⼦)，再将原有集合中的元

素拷贝到新的集合中。如果产⽣多次扩容，则会产⽣很多⽆⽤的中间集合对象，以及多次⽆意义的元素拷贝，性能低下。

正确⽰例： 估计存储的元素个数最⼤为10000，使⽤ArrayList集合

List list = new ArrayList(10000);

## 3、遍历集合，使⽤迭代器替代循环调⽤带索引的get⽅法

遍历集合

建议：使⽤迭代器遍历集合

杜绝：循环调⽤带索引的get⽅法

原因：迭代器维护了遍历集合的“指针”及内部状态，它知道如何⾼效的遍历集合。⽽集合提供的带索引的get⽅法，对某些集合⽽⾔查找

索引需要从第⼀个元素开始遍历(如LinkedList)，效率⾮常低下。

注：虽然迭代器遍历某些特定集合性能并⾮最优，例如，遍历ArrayList，使⽤循环调⽤带索引的get⽅法就⽐迭代器性能略⾼⼀些，但是绝

⼤多数情况下迭代器遍历集合都是最优的。对LinkedList，带索引的get⽅法要从第⼀个元素开始查找，使⽤循环调⽤带索引的get⽅法遍历

效率⾮常低。

正确⽰例：

List list =…

Iterator it = list.iterator();

while(it.hasNext())

{

it.next()

}

错误⽰例：

List list =…

for(int i=0; i< list.size(); i++)

{ list.get(i) }