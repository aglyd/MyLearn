# [26 02向上转型和向下转型的总结和作用](https://www.cnblogs.com/xuwangqi/p/11143354.html)

向上转型：父类引用指向子类对象，例如：Father f1 = new Son();  当子类向上造型后的对象的方法中不存在子类的自己的特色的方法，只有父类的方法。而且子类对于父类进行重写的方法。向上造型的对象的方法为重写后新的方法。

在这个例子中 person类分别是man,weman,child 的父类

```java
package DAY12;

public class Demo {

    public static void main(String[] args) {
        Person p=new man();//向上转型，编译是Person对象，运行的时候是man类对象 声明是父类,调用的方法却只能是子类的
        System.out.println(p.getClass());//class DAY12.man
        p.speak();// 我是man类          此时运行调用的是man类中的方法
    }

}
class Person{
    String name;
    int age;
    void speak()
    {
        System.out.println("我是Person类，是所有人的父类");
    }
}
class man extends Person
{
    void speak() {
        System.out.println("我是man类");
    }
    void doThing() {
        System.out.println("我是man类，我可以做重活"); //这是子类的特有方法
    }
}

class weman extends Person
{
    void speak() {
        System.out.println("我是weman类");
    }
    void doThing() {
        System.out.println("我是weman类，我可以做针线活"); //这是子类的特有方法
    }
}

class child extends Person
{
    void speak() {
        System.out.println("我是child类");
    }
    void doThing() {
        System.out.println("我是child类，我可以玩游戏"); //这是子类的特有方法
    }
}
```

.向下造型：把指向子类对象的父类引用赋给子类引用，需要强制转换，父类引用的对象转换为子类类型。但是对于父类的引用对象一定要是由子类实例化的，也就是说向下造型的出现一般的情况都是和向上造型一起出现的。例如：

Father f1 = new Son();

Son s1 = (Son)f1;

但有运行出错的情况：

Father f2 = new Father();

Son s2 = (Son)f2;//编译无错但运行会出现错误

在不确定父类引用是否指向子类对象时，可以用instanceof来判断：

if(f3 instanceof Son){

   Son s3 = (Son)f3;

}

也可以来个通俗点的：

A类是父类，B类是子类

A a = new A(); B b = new B();

A a1 = b; ---向上造型

B b1 =(B)a1;-----向下造型

B b2 = (A)a;--------这个就会报错。ClassCastException

详情可以看我的https://www.cnblogs.com/xuwangqi/p/11106535.html

作用:就好像是一个工厂可以生产多种品牌的电脑，那么我们让工厂生产的时候如果是按品牌给工厂，那么我们要工厂开多个品牌的流水线生产，而不同品牌的电脑又可以统称为电脑，这个时候我们给工厂就让他生产电脑，等他生产出来的时候我们在贴上不同品牌的商标。这样让工厂的使用更方便了。

这个过程就是电脑作为不同品牌的父类，生产的时候先向上转型成电脑，随后在向下转型转换为个品牌的电脑。讲的不好，请谅解。



---

# [Java 多态](https://www.runoob.com/java/java-polymorphism.html)

### 多态的优点

- \1. 消除类型之间的耦合关系
- \2. 可替换性
- \3. 可扩充性
- \4. 接口性
- \5. 灵活性
- \6. 简化性

### 多态存在的三个必要条件

- 继承
- 重写

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

以下是一个多态实例的演示，详细说明请看注释：

```java
public class Test {
    public static void main(String[] args) {
      show(new Cat());  // 以 Cat 对象调用 show 方法
      show(new Dog());  // 以 Dog 对象调用 show 方法
                
      Animal a = new Cat();  // 向上转型  
      a.eat();               // 调用的是 Cat 的 eat
      Cat c = (Cat)a;        // 向下转型  
      c.work();        // 调用的是 Cat 的 work
  }  
            
    public static void show(Animal a)  {
      a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}
 
abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}  
  
class Dog extends Animal {  
    public void eat() {  
        System.out.println("吃骨头");  
    }  
    public void work() {  
        System.out.println("看家");  
    }  
}
```

执行以上程序，输出结果为：

```
吃鱼
抓老鼠
吃骨头
看家
吃鱼
抓老鼠
```

## 虚函数

虚函数的存在是为了多态。

Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。

### 重写

我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。

我们已经讨论了方法的重写，也就是子类能够重写父类的方法。

当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

要想调用父类中被重写的方法，则必须使用关键字 **super**。

```java
/* 文件名 : Employee.java */
public class Employee {
   private String name;
   private String address;
   private int number;
   public Employee(String name, String address, int number) {
      System.out.println("Employee 构造函数");
      this.name = name;
      this.address = address;
      this.number = number;
   }
   public void mailCheck() {
      System.out.println("邮寄支票给： " + this.name
       + " " + this.address);
   }
   public String toString() {
      return name + " " + address + " " + number;
   }
   public String getName() {
      return name;
   }
   public String getAddress() {
      return address;
   }
   public void setAddress(String newAddress) {
      address = newAddress;
   }
   public int getNumber() {
     return number;
   }
}
```

```java
/* 文件名 : Salary.java */
public class Salary extends Employee
{
   private double salary; // 全年工资
   public Salary(String name, String address, int number, double salary) {
       super(name, address, number);
       setSalary(salary);
   }
   public void mailCheck() {
       System.out.println("Salary 类的 mailCheck 方法 ");
       System.out.println("邮寄支票给：" + getName()
       + " ，工资为：" + salary);
   }
   public double getSalary() {
       return salary;
   }
   public void setSalary(double newSalary) {
       if(newSalary >= 0.0) {
          salary = newSalary;
       }
   }
   public double computePay() {
      System.out.println("计算工资，付给：" + getName());
      return salary/52;
   }
}	
```

```java
/* 文件名 : VirtualDemo.java */
public class VirtualDemo {
   public static void main(String [] args) {
      Salary s = new Salary("员工 A", "北京", 3, 3600.00);
      Employee e = new Salary("员工 B", "上海", 2, 2400.00);
      System.out.println("使用 Salary 的引用调用 mailCheck -- ");
      s.mailCheck();
      System.out.println("\n使用 Employee 的引用调用 mailCheck--");
      e.mailCheck();
    }
}
```

以上实例编译运行结果如下：

```
Employee 构造函数
Employee 构造函数
使用 Salary 的引用调用 mailCheck -- 
Salary 类的 mailCheck 方法 
邮寄支票给：员工 A ，工资为：3600.0

使用 Employee 的引用调用 mailCheck--
Salary 类的 mailCheck 方法 
邮寄支票给：员工 B ，工资为：2400.0
```

### 例子解析

- 实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。
- 当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。
- e 是 Employee 的引用，但引用 e 最终运行的是 Salary 类的 mailCheck() 方法。
- 在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。

以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。

Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。