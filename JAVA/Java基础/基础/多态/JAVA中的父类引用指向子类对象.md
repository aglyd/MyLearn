# JAVA中的父类引用指向子类对象



父类引用指向子类对象指的是：

例如父类Animal，子类Cat,Dog。其中Animal可以是类也可以是接口，Cat和Dog是继承或实现Animal的子类。

Animal animal = new Cat();

即声明的是父类，实际指向的是子类的一个对象。



那这么使用的优点是什么，为什么要这么用？可以用这几个关键词来概括：***\*多态、动态链接，向上转型\****

也有人说这是面向接口编程，可以降低程序的耦合性，即调用者不必关心调用的是哪个对象，只需要针对接口编程就可以了，被调用者对于调用者是完全透明的。让你更关注父类能做什么,而不去关心子类是具体怎么做的,你可以随时替换一个子类,也就是随时替换一个具体实现,而不用修改其他.

以后结合设计模式（如工厂模式，代理模式）和反射机制可能有更深理解。

下面介绍java的多态性和其中的动态链接，向上转型：

面向对象的三个特征：封装、继承和多态；

封装隐藏了类的内部实现机制，可以在不影响使用者的前提下修改类的内部结构，同时保护了数据；

继承是为了重用父类代码，子类继承父类就拥有了父类的成员。

***\*方法的重写、重载与动态连接构成多态性。\****Java之所以引入多态的概念，原因之一是它在类的继承问题上和C++不同，后者允许多继承，这确实给其带来的非常强大的功能，但是复杂的继承关系也给C++开发者带来了更大的麻烦，为了规避风险，Java只允许单继承，派生类与基类间有IS-A的关系（即“猫”is a “动物”）。这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，此外，抽象类和接口也是解决单继承规定限制的重要手段。同时，多态也是面向对象编程的精髓所在。

理解多态，首先要知道“向上转型”。

我定义了一个子类Cat，它继承了Animal类，那么后者就是前者是父类。我可以通过 

Cat c = new Cat(); 
实例化一个Cat的对象，这个不难理解。但当我这样定义时： 

Animal a = new Cat(); 
这代表什么意思呢？ 

很简单，它表示我定义了一个Animal类型的引用，指向新建的Cat类型的对象。**由于Cat是继承自它的父类Animal，所以Animal类型的引用是可以指向Cat类型的对象的。这就是“向上转型”。**

那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的； 

**那什么是动态链接呢？当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。**

下面看一下典型的多态例子：

**[java]** [view plain](http://blog.csdn.net/kaiwii/article/details/8042488#) [copy](http://blog.csdn.net/kaiwii/article/details/8042488#)

1. **class** Father{  
2.   **public** **void** func1(){  
3. ​    func2();  
4.   }  
5.   //这是父类中的func2()方法，因为下面的子类中重写了该方法  
6.   //所以在父类类型的引用中调用时，这个方法将不再有效  
7.   //取而代之的是将调用子类中重写的func2()方法  
8.   **public** **void** func2(){  
9. ​    System.out.println("AAA");  
10.   }  
11. }  
12.   
13. **class** Child **extends** Father{  
14.   //func1(int i)是对func1()方法的一个重载，主要不是重写！ 
15.   //由于在父类中没有定义这个方法，所以它不能被父类类型的引用调用  
16.   //所以在下面的main方法中child.func1(68)是不对的  
17.   **public** **void** func1(**int** i){  
18. ​    System.out.println("BBB");  
19.   }  
20.   //func2()重写了父类Father中的func2()方法  
21.   //如果父类类型的引用中调用了func2()方法，那么必然是子类中重写的这个方法  
22.   **public** **void** func2(){  
23. ​    System.out.println("CCC");  
24.   }  
25. }  
26.   
27. **public** **class** PolymorphismTest {  
28.   **public** **static** **void** main(String[] args) {  
29. ​    Father child = **new** Child();  
30. ​    child.func1();//打印结果将会是什么？  
31. ​    child.func1(68); 
32.   }  
33. }  



上面的程序是个很典型的多态的例子。子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 

那么该程序将会打印出什么样的结果呢？ 
很显然，应该是“CCC”。



对于多态，可以总结以下几点：

***\*一、使用父类类型的引用指向子类的对象； 
二、该引用只能调用父类中定义的方法和变量； 
三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用） 
四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。\****



另转载：

多态是通过: 
1 接口 和 实现接口并覆盖接口中同一方法的几不同的类体现的 
2 父类 和 继承父类并覆盖父类中同一方法的几个不同子类实现的. 

一、基本概念 

多态性：发送消息给某个对象，让该对象自行决定响应何种行为。 
通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。 

java 的这种机制遵循一个原则：**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。** 

\1. 如果a是类A的一个引用，那么，a可以指向类A的一个实例,或者说指向类A的一个子类。 
\2. 如果a是接口A的一个引用，那么,a必须指向实现了接口A的一个类的实例。 


二、Java多态性实现机制 

SUN目前的JVM实现机制，类实例的引用就是指向一个句柄（handle）的指针，这个句柄是一对指针： 
一个指针指向一张表格，实际上这个表格也有两个指针（一个指针指向一个包含了对象的方法表，另外一个指向类对象，表明该对象所属的类型）； 
另一个指针指向一块从java堆中为分配出来内存空间。 

三、总结 

1、通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。 

DerivedC c2=new DerivedC(); 
BaseClass a1= c2; //BaseClass 基类，DerivedC是继承自BaseClass的子类 
a1.play(); //play()在BaseClass，DerivedC中均有定义，即子类覆写了该方法 

分析： 
\* 为什么子类的类型的对象实例可以覆给超类引用？ 
自动实现向上转型。通过该语句，编译器自动将子类实例向上移动，成为通用类型BaseClass； 
\* a.play()将执行子类还是父类定义的方法？ 
子类的。在运行时期，将根据a这个对象引用实际的类型来获取对应的方法。所以才有多态性。一个基类的对象引用，被赋予不同的子类对象引用，执行该方法时，将表现出不同的行为。 

在a1=c2的时候，仍然是存在两个句柄，a1和c2，但是a1和c2拥有同一块数据内存块和不同的函数表。 

2、不能把父类对象引用赋给子类对象引用变量 

BaseClass a2=new BaseClass(); 
DerivedC c1=a2;//出错 

在java里面，向上转型是自动进行的,但是向下转型却不是，需要我们自己定义强制进行。 
c1=(DerivedC)a2; 进行强制转化,也就是向下转型. 

3、记住一个很简单又很复杂的规则，一个类型引用只能引用引用类型自身含有的方法和变量。 
你可能说这个规则不对的，因为父类引用指向子类对象的时候，最后执行的是子类的方法的。 
其实这并不矛盾，那是因为采用了后期绑定，动态运行的时候又根据型别去调用了子类的方法。==而假若子类的这个方法在父类中并没有定义，则会出错。== 
例如，DerivedC类在继承BaseClass中定义的函数外，还增加了几个函数（例如 myFun()） 

分析： 
====当你使用父类引用指向子类的时候，其实jvm已经使用了编译器产生的类型信息调整转换了。== 
这里你可以这样理解，相当于把不是父类中含有的函数从虚拟函数表中设置为不可见的。==注意有可能虚拟函数表中有些函数地址由于在子类中已经被改写了，所以对象虚拟函数表中虚拟函数项目地址已经被设置为子类中完成的方法体的地址了。== 

4、Java与C++多态性的比较 

jvm关于多态性支持解决方法是和c++中几乎一样的， 
只是c++中编译器很多是把类型信息和虚拟函数信息都放在一个虚拟函数表中，但是利用某种技术来区别。 

Java把类型信息和函数信息分开放。Java中在继承以后，子类会重新设置自己的虚拟函数表，这个虚拟函数表中的项目有由两部分组成。从父类继承的虚拟函数和子类自己的虚拟函数。 
虚拟函数调用是经过虚拟函数表间接调用的，所以才得以实现多态的。 

Java的所有函数，除了被声明为final的，都是用后期绑定。 

四. 示例：1个行为,不同的对象,他们具体体现出来的方式不一样, 
比如: 方法重载 overloading 以及 方法重写(覆盖)override 
class Human{ 
void run(){输出 人在跑} 
} 
class Man extends Human{ 
void run(){输出 男人在跑} 
} 
这个时候,同是跑,不同的对象,不一样(这个是方法覆盖的例子) 
class Test{ 
void out(String str){输出 str} 
void out(int i){输出 i} 
} 
这个例子是方法重载,方法名相同,参数表不同 

ok,明白了这些还不够,还用人在跑举例 
Human ahuman=new Man(); 
这样我等于实例化了一个Man的对象,并声明了一个Human的引用,让它去指向Man这个对象 
意思是说,把 Man这个对象当 Human看了. 

比如去动物园,你看见了一个动物,不知道它是什么, "这是什么动物? " "这是大熊猫! " 
这2句话,就是最好的证明,因为不知道它是大熊猫,但知道它的父类是动物,所以, 
这个大熊猫对象,你把它当成其父类 动物看,这样子合情合理. 

这种方式下要注意 new Man();的确实例化了Man对象,所以 ahuman.run()这个方法 输出的 是 "男人在跑 " 

如果在子类 Man下你 写了一些它独有的方法 比如 eat(),而Human没有这个方法, 在调用eat方法时,一定要注意 强制类型转换 ((Man)ahuman).eat(),这样才可以... 对接口来说,情况是类似的... 

**[java]** [view plain](http://blog.csdn.net/kaiwii/article/details/8042488#) [copy](http://blog.csdn.net/kaiwii/article/details/8042488#)

1. 实例:  
2. **package** domatic;  
3.  //定义超类superA  
4.  **class** superA {  
5.   **int** i = 100;  
6.   **void** fun(**int** j) {  
7.    j = i;  
8.    System.out.println("This is superA");  
9.   }  
10.  }  
11. // 定义superA的子类subB  
12. **class** subB **extends** superA {  
13.   **int** m = 1;  
14.   **void** fun(**int** aa) {  
15.    System.out.println("This is subB");  
16.   }  
17. }  
18. // 定义superA的子类subC  
19. **class** subC **extends** superA {  
20.  **int** n = 1;  
21.  **void** fun(**int** cc) {  
22.   System.out.println("This is subC");  
23.  }  
24. }  
25. **class** Test {  
26.  **public** **static** **void** main(String[] args) {  
27.   superA a = **new** superA();  
28.   subB b = **new** subB();  
29.   subC c = **new** subC();  
30.   a = b;  
31.   a.fun(100);  
32.   a = c;  
33.   a.fun(200);  
34.  }  
35. }  


/* 
\* 上述代码中subB和subC是超类superA的子类,我们在类Test中声明了3个引用变量a, b, 
\* c,通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。也许有人会问： 
\* "为什么(1)和(2)不输出：This is superA"。 
\* java的这种机制遵循一个原则：当超类对象引用变量引用子类对象时, 
\* 被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法, 
\* 但是这个被调用的方法必须是在超类中定义过的, 
\* 也就是说被子类覆盖的方法。 
\* 所以,不要被上例中(1)和(2)所迷惑,虽然写成a.fun(),但是由于(1)中的a被b赋值, 
\* 指向了子类subB的一个实例,因而(1)所调用的fun()实际上是子类subB的成员方法fun(), 
\* 它覆盖了超类superA的成员方法fun()；同样(2)调用的是子类subC的成员方法fun()。 
\* 另外,如果子类继承的超类是一个抽象类,虽然抽象类不能通过new操作符实例化, 
\* 但是可以创建抽象类的对象引用指向子类对象,以实现运行时多态性。具体的实现方法同上例。 
\* 不过,抽象类的子类必须覆盖实现超类中的所有的抽象方法, 
\* 否则子类必须被abstract修饰符修饰,当然也就不能被实例化了 
*/





1.JAVA里没有多继承，一个类之能有一个父类。而继承的表现就是多态。一个父类可以有多个子类，而在子类里可以重写父类的方法（例如方法print()），这样每个子类里重写的代码不一样，自然表现形式就不一样。这样用父类的变量去引用不同的子类，在调用这个相同的方法print()的时候得到的结果和表现形式就不一样了，这就是多态，相同的消息（也就是调用相同的方法）会有不同的结果。举例说明： 

**[java]** [view plain](http://blog.csdn.net/gideal_wang/article/details/4913965#) [copy](http://blog.csdn.net/gideal_wang/article/details/4913965#)

1. //父类
2. **public** **class** Father{
3. //父类有一个打孩子方法
4. **public** **void** hitChild(){
5. }
6. }
7. //子类1
8. **public** **class** Son1 **extends** Father{
9. //重写父类打孩子方法
10. **public** **void** hitChild(){
11. System.out.println("为什么打我？我做错什么了！");
12. }
13. }
14. //子类2
15. **public** **class** Son2 **extends** Father{
16. //重写父类打孩子方法
17. **public** **void** hitChild(){
18. System.out.println("我知道错了，别打了！");
19. }
20. }
21. //子类3
22. **public** **class** Son3 **extends** Father{
23. //重写父类打孩子方法
24. **public** **void** hitChild(){
25. System.out.println("我跑，你打不着！");
26. }
27. }
28. //测试类
29. **public** **class** Test{
30. **public** **static** **void** main(String args[]){
31. Father father;
32. father = **new** Son1();
33. father.hitChild();
34. father = **new** Son2();
35. father.hitChild();
36. father = **new** Son3();
37. father.hitChild();
38. }
39. }

都调用了相同的方法，出现了不同的结果！这就是多态的表现。

上面的示例也就是工厂模式的一个简单体现