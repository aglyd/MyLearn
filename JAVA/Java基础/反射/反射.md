# 反射

##  java反射之Method的invoke方法实现

[method.invoke](https://blog.csdn.net/wenyuan65/article/details/81145900)

在框架中经常会会用到method.invoke()方法，用来执行某个的对象的目标方法。以前写代码用到反射时，总是获取先获取Method，然后传入对应的Class实例对象执行方法。然而前段时间研究invoke方法时，发现invoke方法居然包含多态的特性，这是以前没有考虑过的一个问题。那么Method.invoke()方法的执行过程是怎么实现的？它的多态又是如何实现的呢？

本文将从java和JVM的源码实现深入探讨invoke方法的实现过程。

首先给出invoke方法多态特性的演示代码：

public class MethodInvoke {

	public static void main(String[] args) throws Exception {
		Method animalMethod = Animal.class.getDeclaredMethod("print");
		Method catMethod = Cat.class.getDeclaredMethod("print");
		
		Animal animal = new Animal();
		Cat cat = new Cat();
		
		animalMethod.invoke(cat);	//相当于Animal a = New Cat(); a.print();父类指针指向子类实例，执行的是子类的方法
		animalMethod.invoke(animal);           
		
		catMethod.invoke(cat);
		catMethod.invoke(animal);	//相当于Cat obj =New Animal();会报指针无法指向实例对象。
	}

}

class Animal {
	
	public void print() {
		System.out.println("Animal.print()");
	}

}

class Cat extends Animal {
	
	@Override
	public void print() {
		System.out.println("Cat.print()");
	}

}
代码中，Cat类覆盖了父类Animal的print()方法， 然后通过反射分别获取print()的Method对象。最后分别用Cat和Animal的实例对象去执行print()方法。其中animalMethod.invoke(animal)和catMethod.invoke(cat)，示例对象的真实类型和Method的声明Classs是相同的，按照预期打印结果；**animalMethod.invoke(cat)中，由于Cat是Animal的子类，按照多态的特性，子类调用父类的的方法，方法执行时会动态链接到子类的实现方法上。**因此，这里会调用Cat.print()方法；**而catMethod.invoke(animal)中，传入的参数类型Animal是父类，却期望调用子类Cat的方法，因此这一次会抛出异常。**代码打印结果为：

```
Cat.print()`
`Animal.print()`
`Cat.print()`
`Exception in thread "main" java.lang.IllegalArgumentException: object is not an instance of declaring class`
	`at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)`
	`at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)`
	`at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)`
	`at java.lang.reflect.Method.invoke(Unknown Source)`
	at com.wy.invoke.MethodInvoke.main(MethodInvoke.java:17)
```


接下来，我们来看看invoke()方法的实现过程。

------------------------------------------------
